!------------------------------------------------------------------------------
!
! This file is part of the SternheimerGW code.
! Parts of this file have been taken from the chebfun code.
! See http://www.chebfun.org/ for Chebfun information.
! 
! Copyright (C) 2010 - 2018
! The University of Oxford and The Chebfun Developers,
! Henry Lambert, Martin Schlipf, and Feliciano Giustino
!
! SternheimerGW is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! SternheimerGW is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with SternheimerGW. If not, see
! http://www.gnu.org/licenses/gpl.html .
!
!------------------------------------------------------------------------------ 
!> Provides the routines to evaluate the Pade approximation to a function.
MODULE pade_module

  IMPLICIT NONE

  PRIVATE

  PUBLIC pade_robust, pade_coeff_robust, pade_eval_robust

CONTAINS

  !> evaluate the Pade continuation for a given set of Pade coefficients
  SUBROUTINE pade_eval_robust(coeff, freq, val)

    USE kinds, ONLY: dp

    !> a set of coefficients generated by *pade_coeff_robust*
    COMPLEX(dp), INTENT(IN)  :: coeff(:)

    !> the frequency for which the Pade analytic continuation is calculated
    COMPLEX(dp), INTENT(IN)  :: freq

    !> the Pade continuation for the given frequency
    COMPLEX(dp), INTENT(OUT) :: val

    !> value of the numerator
    COMPLEX(dp) num

    !> value of the denominator
    COMPLEX(dp) den

    !> counter for numerator and denominator
    INTEGER ii

    !> first and last element of the loop
    INTEGER first, last

    !> step size of loop (counting backwards)
    INTEGER, PARAMETER :: backward = -1

    !> complex constant of zero
    COMPLEX(dp), PARAMETER :: zero = CMPLX(0.0_dp, 0.0_dp, KIND=dp)

    ! construct the numerator
    first = 3
    last = first + NINT(ABS(coeff(1)))
    num = zero
    DO ii = last, first, backward
      num = coeff(ii) + num * freq
    END DO

    ! construct the denominator
    first = last + 1
    last = first + NINT(ABS(coeff(2)))
    den = zero
    DO ii = last, first, backward
      den = coeff(ii) + den * freq
    END DO

    ! evaluate the value
    val = num / den

  END SUBROUTINE pade_eval_robust

  !> construct robust Pade coefficients and store them in input array
  SUBROUTINE pade_coeff_robust(freq, tol, func)

    USE constants, ONLY: eps12
    USE kinds,     ONLY: dp

    !> frequency mesh - must span circle in complex plane and the first
    !! element must be (R, 0)
    COMPLEX(dp), INTENT(IN)    :: freq(:)

    !> tolerance of the Pade approximation (related to solver accuracy)
    REAL(dp),    INTENT(IN)    :: tol

    !> *on input* values of function on circle <br>
    !! *on output* first element - degree of numerator; second element
    !! degree of denominator; remaining elements first numerator then
    !! denominator
    COMPLEX(dp), INTENT(INOUT) :: func(:,:,:)

    !> radius of the circle in the complex plane
    REAL(dp) radius

    !> loop variable for the row and column of array
    INTEGER ii, jj

    !> degree of the Pade approximation (numerator and denominator)
    INTEGER deg_num, deg_den

    !> Pade coefficients for numerator
    COMPLEX(dp), ALLOCATABLE :: coeff_num(:)

    !> Pade coefficients for numerator
    COMPLEX(dp), ALLOCATABLE :: coeff_den(:)

    !
    ! sanity check
    !
    ! at least 10 frequencies?
    IF (SIZE(freq) < 10) &
      CALL errore(__FILE__, "use at least 10 frequencies to form the circle", 1)
    !
    ! all frequencies on circle?
    radius = REAL(freq(1))
    IF (ANY(ABS(ABS(freq) - radius) > eps12)) &
      CALL errore(__FILE__, "frequencies must span circle in the complex plane", 1)
    !
    ! function and frequency compatible?
    IF (SIZE(freq) /= SIZE(func, 3)) &
      CALL errore(__FILE__, "frequency must be last dimension of array", 1)

    !
    ! evaluate robust Pade approximation
    !
    DO jj = 1, SIZE(func, 2)
      DO ii = 1, SIZE(func, 1)
        !
        ! start with (n,n) Pade approximation and choose n to utilize
        ! most of the frequency points
        deg_num = SIZE(func, 3) / 2 - 2
        deg_den = deg_num
        !
        ! determine Pade coefficients
        CALL pade_robust(radius, func(ii, jj, :), deg_num, deg_den, coeff_num, coeff_den) !, tol, eps12)
        !
        ! store degree and Pade coefficients in array
        func(ii, jj, 1) = deg_num
        func(ii, jj, 2) = deg_den
        func(ii, jj, 3:5 + deg_num + deg_den) = [coeff_num, coeff_den]
        !
      END DO ! ii
    END DO ! jj

  END SUBROUTINE pade_coeff_robust

  !> Pade approximation to a function.
  !!
  !! Constructs a Pade approximant to a function using the robust algorithm from
  !! [1] based on the SVD.
  !!
  !! This code is included in the Chebfun distribution for the convenience of
  !! readers of _Approximation Theory and Approximation Practice_, but it is not
  !! actually a Chebfun code. A Chebfun analogue is CHEBPADE.
  !!
  !! <h4>References:</h4>
  !! [1] P. Gonnet, S. Guettel, and L. N. Trefethen, "ROBUST PADE APPROXIMATION 
  !!     VIA SVD", SIAM Rev., 55:101-117, 2013.
  !!
  SUBROUTINE pade_robust(radius, func, deg_num, deg_den, coeff_num, coeff_den, tol_coeff, tol_fft)

    USE constants,     ONLY: eps14
    USE kinds,         ONLY: dp
    USE lapack_wrapper,ONLY: svd, qr
    USE norm_module,   ONLY: norm

    !> The radius of the circle in the complex plane.
    REAL(dp),    INTENT(IN) :: radius

    !> The values of the function evaluated on a circle in the complex plane.
    !! The derivatives of the functions are computed via FFT.
    COMPLEX(dp), INTENT(IN) :: func(:)

    !> The degree of the numerator (must be positive), potentially modified if
    !! Pade approximation has vanishing terms
    INTEGER,     INTENT(INOUT) :: deg_num

    !> The degree of the denominator (must be positive), potentially modified if
    !! Pade approximation has vanishing terms
    INTEGER,     INTENT(INOUT) :: deg_den

    !> The Pade coefficient vector of the numerator
    COMPLEX(dp), ALLOCATABLE, INTENT(OUT) :: coeff_num(:)

    !> The Pade coefficient vector of the denominator
    COMPLEX(dp), ALLOCATABLE, INTENT(OUT) :: coeff_den(:)

    !> The optional **tol_coeff** argument specifies the relative tolerance for
    !! the coefficients; if omitted, it defaults to 1e-14. Set to 0 to turn off
    !! robustness.
    REAL(dp),    OPTIONAL,    INTENT(IN)  :: tol_coeff

    !> The optional **tol_fft** argument specifies the relative tolerance for
    !! the FFT. Coefficients smaller than it are set to 0; if omitted it defaults
    !! to the value of **tol_coeff**.
    REAL(dp),    OPTIONAL,    INTENT(IN)  :: tol_fft

    !> number of converged elements
    INTEGER rho

    !> number of leading or trailing zeros
    INTEGER lam

    !> local variable for the relative tolerance
    REAL(dp) rel_tol

    !> absolute value for the tolerance
    REAL(dp) abs_tol

    !> local variable for the relative tolerance of the fft
    REAL(dp) rel_tol_fft

    !> singular values of matrix
    REAL(dp),    ALLOCATABLE :: sigma(:)

    !> the coefficients of the Taylor series
    COMPLEX(dp), ALLOCATABLE :: coeff(:)

    !> the first row of the Toeplitz matrix
    COMPLEX(dp), ALLOCATABLE :: row(:)

    !> the first column of the Toeplitz matrix
    COMPLEX(dp), ALLOCATABLE :: col(:)

    !> the constructed Toeplitz matrix
    COMPLEX(dp), ALLOCATABLE :: zmat(:,:)

    !> matrix for calculating the numerical rank
    COMPLEX(dp), ALLOCATABLE :: cmat(:,:)

    !> U matrix for singular value decomposition
    COMPLEX(dp), ALLOCATABLE :: umat(:,:)

    !> V matrix for singular value decomposition
    COMPLEX(dp), ALLOCATABLE :: vmat(:,:)

    !> D matrix is diagonal, so we can store it in a vector
    COMPLEX(dp), ALLOCATABLE :: dmat(:)

    !> Q matrix of the QR factorization
    COMPLEX(dp), ALLOCATABLE :: qmat(:,:)

    !> numeric precision (1 + eps) > 1
    REAL(dp),    PARAMETER :: eps = EPSILON(1.0_dp)

    !> complex constant of 1
    COMPLEX(dp), PARAMETER :: one = CMPLX(1.0_dp, 0.0_dp, KIND=dp)

    !> complex constant of 0
    COMPLEX(dp), PARAMETER :: zero = CMPLX(0.0_dp, 0.0_dp, KIND=dp)

    !> use infinity norm
    LOGICAL, PARAMETER :: inf = .TRUE.

    ! sanity check of the input
    IF (radius <= 0) &
      CALL errore(__FILE__, "radius in the complex plane must be > 0", 1)
    IF (deg_num < 0) &
      CALL errore(__FILE__, "degree of numerator must be positive", deg_num)
    IF (deg_den < 0) &
      CALL errore(__FILE__, "degree of denominator must be positive", deg_den)

    ! default value of tolerance 1e-14
    IF (PRESENT(tol_coeff)) THEN
      rel_tol = tol_coeff
    ELSE
      rel_tol = eps14
    END IF

    ! use same tolererance for FFT and coeff unless specified otherwise
    IF (PRESENT(tol_fft)) THEN
      rel_tol_fft = tol_fft
    ELSE
      rel_tol_fft = rel_tol
    END IF

    ! Compute coefficients
    CALL pade_derivative(radius, func, rel_tol_fft, deg_num + deg_den + 1, coeff)

    ! determine the absolute value of the tolerance
    abs_tol = rel_tol * norm(coeff)

    !
    ! Compute the Pade approximation.
    !
    IF (norm(coeff(1:deg_num + 1), inf) <= rel_tol * norm(coeff, inf)) THEN
      !
      ! special case - the function is 0
      !
      ! set numerator to 0
      deg_num = 0
      ALLOCATE(coeff_num(deg_num + 1))
      coeff_num = zero
      !
      ! set denominator to 1
      deg_den = 0
      ALLOCATE(coeff_den(deg_den + 1))
      coeff_den = one
      !
      RETURN
      !
    END IF
    !
    ! general case
    !
    ! First row/column of Toeplitz matrix.
    ALLOCATE(row(deg_den + 1))
    row = zero
    row(1) = coeff(1)
    !
    ALLOCATE(col(SIZE(coeff)))
    col = coeff;
    !
    ! Do diagonal hopping across block. 
    DO WHILE (.TRUE.)
      !
      ! Special case n == 0.
      IF (deg_den == 0) THEN
        !
        ALLOCATE(coeff_num(deg_num + 1))
        coeff_num = coeff(:deg_num + 1) 
        !
        ALLOCATE(coeff_den(deg_den + 1))
        coeff_den = one
        !
        EXIT
        !
      END IF
      !
      ! Form Toeplitz matrix.
      CALL toeplitz_nonsym(col(1:deg_num + deg_den + 1), row(1:deg_den + 1), zmat)
      !
      ! Compute numerical rank.
      ALLOCATE(cmat(deg_den, SIZE(zmat, 2))) 
      cmat = zmat(deg_num + 2:deg_num + deg_den + 1, :)
      CALL svd(cmat, sigma)
      rho = COUNT(sigma > abs_tol)
      !
      IF (rho == deg_den) EXIT
      !
      ! Decrease mn, n if rank-deficient.
      deg_num = deg_num - (deg_den - rho)
      deg_den = rho
      !
      DEALLOCATE(zmat, cmat)
      !
    END DO ! while
    !
    DEALLOCATE(coeff)
    !
    ! Hopping finished. Now compute b and a.
    IF (deg_num > 1) THEN
      !
      CALL svd(cmat, sigma, umat, vmat)
      !
      ! Null vector gives b.
      ALLOCATE(coeff_den(deg_den + 1))
      coeff_den = vmat(deg_den + 1, :)
      !
      ! Do final computation via reweighted QR for better zero preservation.
      ALLOCATE(dmat(SIZE(coeff_den)))
      dmat = ABS(coeff_den) + SQRT(eps)
      ! replace C -> (C D)^T
      CALL matmul_transpose(cmat, dmat)
      CALL qr(cmat, qmat)
      !
      ! Compensate for reweighting.
      coeff_den = dmat * qmat(:, deg_den + 1)
      coeff_den = coeff_den / norm(coeff_den)
      !
      ! Multiplying gives a.
      ALLOCATE(coeff_num(deg_num + 1))
      coeff_num = MATMUL(zmat(1:deg_num + 1, 1:deg_den + 1), coeff_den)
      !
      ! Count leading zeros of b.
      lam = first_nonzero(coeff_den, rel_tol) - 1
      !
      IF (lam > 0) THEN
        !
        ! Discard leading zeros of b and a.
        deg_num = deg_num - lam
        deg_den = deg_den - lam
        !
        ALLOCATE(coeff(deg_num + 1))
        coeff = coeff_num(lam + 1:)
        CALL MOVE_ALLOC(coeff, coeff_num)
        !
        ALLOCATE(coeff(deg_den + 1))
        coeff = coeff_den(lam + 1:)
        CALL MOVE_ALLOC(coeff, coeff_den)
        !
      END IF ! lam > 0
      !
      ! Discard trailing zeros of b.
      lam = last_nonzero(coeff_den, rel_tol) - 1
      !
      IF (lam /= deg_den) THEN
        !
        deg_den = lam
        !
        ALLOCATE(coeff(deg_den + 1))
        coeff = coeff_den(:deg_den + 1)
        CALL MOVE_ALLOC(coeff, coeff_den)
        !
      END IF ! lam /= deg_den
      !
    END IF ! deg_num > 1
    !
    ! Discard trailing zero coefficients in a.
    lam = last_nonzero(coeff_num, abs_tol) - 1
    !
    IF (lam /= deg_num) THEN
      !
      deg_num = lam
      !
      ALLOCATE(coeff(deg_num + 1))
      coeff = coeff_num(:deg_num + 1)
      CALL MOVE_ALLOC(coeff, coeff_num)
      !
    END IF ! lam /= deg_num
    !
    ! Normalize.
    coeff_num = coeff_num / coeff_den(1)
    coeff_den = coeff_den / coeff_den(1)

  END SUBROUTINE pade_robust

  !> determine the derivatives of the function
  !!
  !! we use a FFT to evaluate the derivative of the function
  SUBROUTINE pade_derivative(radius, func, tol, num_deriv, deriv)

    USE constants,   ONLY: eps14
    USE fft_scalar,  ONLY: cft_1z
    USE kinds,       ONLY: dp
    USE norm_module, ONLY: norm

    !> The radius of the circle in the complex plane.
    REAL(dp),    INTENT(IN) :: radius

    !> The values of the function evaluated on a circle in the complex plane.
    COMPLEX(dp), INTENT(IN) :: func(:)

    !> tolerance to identify small coeffficients
    REAL(dp),    INTENT(IN) :: tol

    !> The number of derivatives that should be generated
    INTEGER,     INTENT(IN) :: num_deriv

    !> The derivatives of the functions are computed via FFT.
    COMPLEX(dp), ALLOCATABLE, INTENT(OUT) :: deriv(:)

    !> use a backward FFT
    INTEGER,     PARAMETER :: backward = -1

    !> the number of FFTs done per call
    INTEGER,     PARAMETER :: num_fft = 1

    !> real constant of 1
    REAL(dp),    PARAMETER :: one = 1.0_dp

    !> complex constant of 0
    COMPLEX(dp), PARAMETER :: zero = CMPLX(0.0_dp, 0.0_dp, KIND=dp)

    !> the number of points in a FFT
    INTEGER num_point

    !> counter on the derivatives
    INTEGER ipoint

    !> rescale the derivatives if the radius is not 1.0
    REAL(dp) rescale

    !> absolute value of the tolerance
    REAL(dp) abs_tol

    !> work array for FFT
    COMPLEX(dp), ALLOCATABLE :: work(:)

    ! create array for FFT
    num_point = SIZE(func)
    ALLOCATE(work(num_point))

    ! evalute FFT of function
    ! work contains now the derivatives up to a factor
    CALL cft_1z(func, num_fft, num_point, num_point, backward, work)

    ! create array for the derivatives
    ALLOCATE(deriv(num_deriv))
    deriv = zero

    ! evaluate the derivatives (truncating or filling with zeros as needed)
    num_point = MIN(num_deriv, num_point)
    deriv(:num_point) = work(:num_point)

    ! rescale the derivatives by radius^(-order of derivative)
    IF (ABS(radius - one) > eps14) THEN
      !
      rescale = one
      DO ipoint = 2, num_point
        !
        rescale = rescale / radius
        deriv(ipoint) = deriv(ipoint) * rescale
        !
      END DO ! ipoint
    END IF ! radius /= 1

    ! Discard near-zero coefficients.
    abs_tol = tol * norm(deriv)
    WHERE(ABS(deriv) < abs_tol)
      deriv = zero
    END WHERE

    ! Remove imaginary rounding errors. (Make real functions real.)
    IF (norm(AIMAG(deriv), .TRUE.) < abs_tol) THEN
      deriv = REAL(deriv)
    END IF

  END SUBROUTINE pade_derivative

  !> create a nonsymetric Toeplitz matrix (mathlab-like behavior)
  SUBROUTINE toeplitz_nonsym(col, row, matrix)

    USE constants, ONLY: eps14
    USE kinds,     ONLY: dp

    !> the first column of the matrix
    COMPLEX(dp), INTENT(IN) :: col(:)

    !> the first row of the matrix
    COMPLEX(dp), INTENT(IN) :: row(:)

    !> the resulting Toeplitz matrix
    COMPLEX(dp), ALLOCATABLE, INTENT(OUT) :: matrix(:,:)

    !> the number of row and colums
    INTEGER num_row, num_col

    !> counter on row and colums
    INTEGER irow, icol

    num_row = SIZE(col)
    num_col = SIZE(row)
    ALLOCATE(matrix(num_row, num_col))

    ! trivial case - zero length array
    IF (num_row == 0 .OR. num_col == 0) RETURN
    
    ! sanity check of the input
    IF (ABS(col(1) - row(1)) > eps14) THEN
      WRITE(0,*) 'Warning: First element of input column does not match first &
                 &element of input row. Column wins diagonal conflict.'
    END IF

    ! create the Toeplitz matrix
    DO icol = 1, num_col
      DO irow = 1, num_row
        !
        IF (irow < icol) THEN
          ! use row for upper triangle
          matrix(irow, icol) = row(icol - irow + 1)
        ELSE
          ! use col for lower triangle and diagonal
          matrix(irow, icol) = col(irow - icol + 1)
        END IF
        !
      END DO ! irow
    END DO ! icol

  END SUBROUTINE toeplitz_nonsym

  !> Evaluate \f$(C D)^{\text{T}}\f$, where D is diagonal.
  SUBROUTINE matmul_transpose(cmat, dmat)

    USE kinds, ONLY: dp

    !> *on input* the matrix C <br>
    !! *on output* the result \f$(C D)^{\text{T}}\f$
    COMPLEX(dp), INTENT(INOUT), ALLOCATABLE :: cmat(:,:)

    !> the diagonal elements of the matrix D
    COMPLEX(dp), INTENT(IN)  :: dmat(:)

    !> work array that will store the output
    COMPLEX(dp), ALLOCATABLE :: work(:,:)

    ! counter on the columns of C
    INTEGER icol

    ! create work array - transpose of C
    ALLOCATE(work(SIZE(cmat, 2), SIZE(cmat, 1)))

    DO icol = 1, SIZE(cmat, 2)
      !
      ! C_ij D_jj
      work(icol, :) = cmat(:, icol) * dmat(icol)
      !
    END DO ! icol

    ! copy work to output
    CALL MOVE_ALLOC(work, cmat)

  END SUBROUTINE matmul_transpose

  !> determine first nonzero element of complex array (up to a tolerance)
  FUNCTION first_nonzero(array, tol)

    USE kinds, ONLY: dp

    !> the array of which the nonzero elements are determined
    COMPLEX(dp), INTENT(IN) :: array(:)

    !> the tolerance up to which elements are considered as 0
    REAL(dp),    INTENT(IN) :: tol

    !> the position of the first nonzero element
    INTEGER first_nonzero

    !> a ordered array of integers
    INTEGER, ALLOCATABLE :: order(:)

    !> counter to initialize the order array
    INTEGER ii

    ! create a ordered integer array
    ALLOCATE(order(SIZE(array)))
    order = [ (ii, ii = 1, SIZE(array)) ]

    ! determine the first element for which the mask is true
    first_nonzero = MINLOC(order, 1, ABS(array) > tol)

  END FUNCTION first_nonzero

  !> determine last nonzero element of complex array (up to a tolerance)
  FUNCTION last_nonzero(array, tol)

    USE kinds, ONLY: dp

    !> the array of which the nonzero elements are determined
    COMPLEX(dp), INTENT(IN) :: array(:)

    !> the tolerance up to which elements are considered as 0
    REAL(dp),    INTENT(IN) :: tol

    !> the position of the last nonzero element
    INTEGER last_nonzero

    !> a ordered array of integers
    INTEGER, ALLOCATABLE :: order(:)

    !> counter to initialize the order array
    INTEGER ii

    ! create a ordered integer array
    ALLOCATE(order(SIZE(array)))
    order = [ (ii, ii = 1, SIZE(array)) ]

    ! determine the last element for which the mask is true
    last_nonzero = MAXLOC(order, 1, ABS(array) > tol)

  END FUNCTION last_nonzero

END MODULE pade_module
