!------------------------------------------------------------------------------
!
! This file is part of the SternheimerGW code.
!
! Copyright (C) 2010 - 2018
! Henry Lambert, Martin Schlipf, and Feliciano Giustino
!
! SternheimerGW is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! SternheimerGW is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with SternheimerGW. If not, see
! http://www.gnu.org/licenses/gpl.html .
!
!------------------------------------------------------------------------------
! NOTE: This file is automatically generated - do NOT modify.
! Modify the definition file input_gw.yml instead.
!------------------------------------------------------------------------------
!> Automatically generated input reader for SternheimerGW
MODULE gw_input_module

  USE kinds, ONLY: DP
  USE debug_module, ONLY: debug_type

  IMPLICIT NONE

  !> contains all data read from gw_input
  TYPE gw_input_type

    !> The title allows to print a small description what this calculation
    !! does and is reprinted to the output.
    CHARACTER(LEN=75) :: title

    !> Use the prefix variable of the PW calculation.
    CHARACTER(LEN=256) :: prefix

    !> Use the outdir variable of the PW calculation.
    CHARACTER(LEN=256) :: outdir

    !> The grid used to integrate the density reponse needed for the
    !! screened Coulomb interaction. If not set, defaults to the grid used in the
    !! scf calculation.
    INTEGER, DIMENSION(3) :: kpt_grid

    !> The grid used to integrate the screened Coulomb and the exchange
    !! contribution to the self energy.
    INTEGER, DIMENSION(3) :: qpt_grid

    !> Specifies which method is used to truncate the Coulomb potential.
    !! Possible options are
    !!
    !! - not using any truncation 'none', 'off', 'false', 'no', 'no truncation'
    !! - using a spherical truncation 'on', 'true', 'yes', 'spherical', 'spherical truncation'
    !! - using a film geometry truncation (expects film in x-y plane)
    !! 'film', 'film truncation', '2d', '2d truncation'
    !!
    !! - spherical truncation using the QE coulomb_vcut module 'vcut spherical',
    !! 'vcut spherical truncation', 'spherical vcut', 'spherical truncation vcut'
    !!
    !! - Wigner-Seitz truncation using the QE coulomb_vcut module 'wigner-seitz', 'wigner-seitz
    !! truncation', 'ws', 'ws truncation'
    CHARACTER(LEN=80) :: truncation

    !> Number of bands for which the GW correction is evaluated. Note that it
    !! has to be larger than the number of occupied states so that the Fermi energy can
    !! be calculated.
    INTEGER :: num_band

    !> This flag determines whether G and W are convoluted along the imaginary
    !! or the real frequency axis.
    LOGICAL :: int_imag_axis

    !> Small imaginary component used to shift the real frequencies into the
    !! complex plane (in eV).
    REAL(DP) :: eta

    !> Specify whether the screened Coulomb interaction is calculated.
    LOGICAL :: do_coul

    !> Evaluate only the dielectric function. Note that this will overwrite the
    !! settings of do_coul, do_corr, do_exch, and do_matrix_el.
    LOGICAL :: do_epsil

    !> Specify which method is used to solve for the screened Coulomb interaction
    !!
    !! - 'direct' determine the dielectric function and invert
    !! - 'iter' or 'iterative' to determine the inverse of the dielectric function iteratively
    !! which requires no matrix inversion and hence less memory
    CHARACTER(LEN=256) :: solve_coul

    !> Number of iterations for the iterative solver.
    INTEGER :: num_iter_coul

    !> Number of potentials that are mixed in the iterative solver.
    INTEGER :: num_mix_coul

    !> Use the small group of q to reduce the amount of G vectors for which the
    !! linear response is calculated.
    LOGICAL :: use_symm_coul

    !> Shift of the projector used in the linear response equation. If negative
    !! will be determined automatically (only for semiconductors). For metals set to a
    !! small value (1e-5) and converge towards 0 until the dielectric response doesn't change.
    REAL(DP) :: shift_proj

    !> Order in which the linear solvers are tried for the Coulomb interaction
    !!
    !! - 1 - BiCGstab(l) with multishift
    !! - 2 - BiCGstab(l) without multishift
    !! - 3 - linear solver developed for SternheimerGW
    !! - 0 - no linear solver
    INTEGER, DIMENSION(10) :: priority_coul

    !> The threshold to which the linear solver is converged. For the iterative solver
    !! smaller values are necessary (~1e-8).
    REAL(DP) :: thres_coul

    !> The maximum number of iterations a linear solver will try before aborting.
    INTEGER :: max_iter_coul

    !> The parameter lmax controls the number of BiCG steps in the BiCGstab solver
    !! before doing an MR step. It has no effect for other solvers.
    INTEGER :: lmax_coul

    !> Model used to perform the analytic continuation from the coarse mesh, on which
    !! the linear solver works, onto the dense mesh, where the integration is performed.
    !! Possible choices
    !!
    !! - 'gn', 'pp', or 'godby-needs', Godby-Needs plasmon pole model
    !! - 'pade', Pade approximation
    !! - 'pade robust', robust method to determine Pade approximant, requires the initial
    !! frequency mesh to be on a circle
    !!
    !! - 'aaa' adaptive Antoulas-Anderson (AAA) method for calcuting a rational approximant
    !! - 'aaa pole' AAA method combined with removal of weak residue
    CHARACTER(LEN=256) :: model_coul

    !> Select which method is used to enforce the W(w) = W(-w) symmetry to improve
    !! the accuracy of the Pade approximation. Only works if model_coul is 'pade' or 'aaa'
    !! where by default the number of points are doubles. Note that switching off symmetry
    !! should only be used for testing purposes.
    !! Possible choices
    !!
    !! - 0 do not use symmetry
    !! - 1 for every frequency w /= 0 also add W(-w) with the same value
    !! - 2 fit W(w^2) instead of W(w)
    INTEGER :: freq_symm_coul

    !> Upper boundary of the frequency integration grid when convoluting G and W
    !! (in eV). Note that we will integrate from -x to x, where x is the value set here.
    REAL(DP) :: max_freq_coul

    !> Number of frequency points in the integration grid when convoluting G and W.
    INTEGER :: num_freq_coul

    !> Plot the screened Coulomb interaction along the real or imaginary frequency
    !! axis with the grid set by max_freq_coul and num_freq_coul. Note that you should reduce
    !! the correlation cutoff or the q-point grid otherwise you will write a lot of data.
    LOGICAL :: plot_coul

    !> Order in which the linear solvers are tried for the Green's function
    !!
    !! - 1 - BiCGstab with multishift
    !! - 2 - BiCGstab without multishift
    !! - 3 - linear solver developed for SternheimerGW
    !! - 0 - no linear solver
    INTEGER, DIMENSION(10) :: priority_green

    !> The threshold to which the linear solver for the Green's function is converged.
    REAL(DP) :: thres_green

    !> The maximum number of iterations a linear solver will try before aborting.
    INTEGER :: max_iter_green

    !> The parameter lmax controls the number of BiCG steps in the BiCGstab solver
    !! before doing an MR step. It has no effect for other solvers.
    INTEGER :: lmax_green

    !> Determines whether the correlation self energy is evaluated.
    LOGICAL :: do_corr

    !> Energy cutoff used to evaluate the correlation self energy. Important
    !! convergence parameter with very significant impact on computation time.
    REAL(DP) :: ecut_corr

    !> Lower frequency boundary (in eV) for the correlation self energy. Set to 0
    !! when using imaginary axis integration or the minimum relevant frequency for integration
    !! along the real axis.
    REAL(DP) :: min_freq_corr

    !> Upper frequency boundary (in eV) for the correlation self energy. Convergence
    !! parameter when using imaginary axis integration or the maximum relevant frequency for
    !! integration along the real axis.
    REAL(DP) :: max_freq_corr

    !> Number of frequency points for the correlation self energy. Convergence parameter
    !! when using imaginary axis integration.
    INTEGER :: num_freq_corr

    !> Determines whether the exchange self energy is evaluated.
    LOGICAL :: do_exch

    !> Energy cutoff used to evaluate the exchange self energy.
    REAL(DP) :: ecut_exch

    !> Determines whether the matrix elements of the self energy are calculated.
    LOGICAL :: do_matrix_el

    !> Lower frequency boundary for window in which the matrix elements of the
    !! self energy are evaluated (for imaginary frequency integration only).
    REAL(DP) :: min_freq_wind

    !> Upper frequency boundary for window in which the matrix elements of the
    !! self energy are evaluated (for imaginary frequency integration only).
    REAL(DP) :: max_freq_wind

    !> Number of frequency points in window in which the matrix elements of the
    !! self energy are evaluated (for imaginary frequency integration only).
    INTEGER :: num_freq_wind

    !> This can be used to restart a calculation where not all of the q points
    !! finished. It determines for which q point the screened Coulomb interaction is evaluated.
    INTEGER :: first_qpt

    !> This can be used for convergence testing or debugging purposes. It will
    !! abort the calculation after the screened Coulomb interaction for a single q point is
    !! evaluated.
    LOGICAL :: only_one_qpt

    !> This can be used to limit the k points for which the correlation self
    !! energy is evaluated. This determines the lower limit, use last_kpt for the upper limit.
    INTEGER :: first_kpt

    !> This can be used to limit the k points for which the correlation self
    !! energy is evaluated. This determines the upper limit, use last_kpt for the lower limit.
    !! If set to -2 (default), all k points are calculated.
    INTEGER :: last_kpt

    !> Verbosity of the output in the NSCF calculation. Set to either 'low'
    !! (default) or 'high'.
    CHARACTER(LEN=80) :: verbosity

    !> Allows to activate debugging for various parts of the code. Note that the
    !! code must be compiled with 'make debug' to enable debugging.
    TYPE(DEBUG_TYPE) :: debug

  END TYPE gw_input_type

  !> contains all data read from gw_output
  TYPE gw_output_type

    !> Directory in which the files generated by SternheimerGW are stored. If
    !! not set, it will default to the PW outdir.
    CHARACTER(LEN=256) :: directory

    !> Extension to filename in which the screened Coulomb matrix is stored. The
    !! file generated will have the name prefix.file_coul.
    CHARACTER(LEN=256) :: file_coul

    !> Extension to filename in which the exchange contribution is stored. The
    !! file generated will have the name prefix.file_exch.
    CHARACTER(LEN=256) :: file_exch

    !> Extension to filename in which the correlation contribution is stored. The
    !! file generated will have the name prefix.file_corr.
    CHARACTER(LEN=256) :: file_corr

    !> XML file that contains both exchange and correlation contribution and some
    !! information to allow reading that information.
    CHARACTER(LEN=256) :: file_sigma

    !> If set, write the eigenvalues obtained in the DFT calculation along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_dft

    !> If set, write the quasi-particle eigenvalues calculation along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_gw

    !> If set, write the expectation value of the exchange-correlation potential along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_vxc

    !> If set, write the expectation value of the bare HF exchange along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_hf

    !> If set, write the quasi-particle renormalization factor Z along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_renorm

  END TYPE gw_output_type

CONTAINS

  !> read the user input from the input file
  SUBROUTINE gw_input_read(gw_input_t, gw_output_t)

    USE io_global, ONLY: stdin

    !> contains the user input in namelist gw_input
    TYPE(gw_input_type), INTENT(OUT) :: gw_input_t

    !> contains the user input in namelist gw_output
    TYPE(gw_output_type), INTENT(OUT) :: gw_output_t

    !
    !  variables used for namelist gw_input
    !
    !> The title allows to print a small description what this calculation
    !! does and is reprinted to the output.
    CHARACTER(LEN=75) :: title
    !
    !> Use the prefix variable of the PW calculation.
    CHARACTER(LEN=256) :: prefix
    !
    !> Use the outdir variable of the PW calculation.
    CHARACTER(LEN=256) :: outdir
    !
    !> The grid used to integrate the density reponse needed for the
    !! screened Coulomb interaction. If not set, defaults to the grid used in the
    !! scf calculation.
    INTEGER, DIMENSION(3) :: kpt_grid
    !
    !> The grid used to integrate the screened Coulomb and the exchange
    !! contribution to the self energy.
    INTEGER, DIMENSION(3) :: qpt_grid
    !
    !> Specifies which method is used to truncate the Coulomb potential.
    !! Possible options are
    !!
    !! - not using any truncation 'none', 'off', 'false', 'no', 'no truncation'
    !! - using a spherical truncation 'on', 'true', 'yes', 'spherical', 'spherical truncation'
    !! - using a film geometry truncation (expects film in x-y plane)
    !! 'film', 'film truncation', '2d', '2d truncation'
    !!
    !! - spherical truncation using the QE coulomb_vcut module 'vcut spherical',
    !! 'vcut spherical truncation', 'spherical vcut', 'spherical truncation vcut'
    !!
    !! - Wigner-Seitz truncation using the QE coulomb_vcut module 'wigner-seitz', 'wigner-seitz
    !! truncation', 'ws', 'ws truncation'
    CHARACTER(LEN=80) :: truncation
    !
    !> Number of bands for which the GW correction is evaluated. Note that it
    !! has to be larger than the number of occupied states so that the Fermi energy can
    !! be calculated.
    INTEGER :: num_band
    !
    !> This flag determines whether G and W are convoluted along the imaginary
    !! or the real frequency axis.
    LOGICAL :: int_imag_axis
    !
    !> Small imaginary component used to shift the real frequencies into the
    !! complex plane (in eV).
    REAL(DP) :: eta
    !
    !> Specify whether the screened Coulomb interaction is calculated.
    LOGICAL :: do_coul
    !
    !> Evaluate only the dielectric function. Note that this will overwrite the
    !! settings of do_coul, do_corr, do_exch, and do_matrix_el.
    LOGICAL :: do_epsil
    !
    !> Specify which method is used to solve for the screened Coulomb interaction
    !!
    !! - 'direct' determine the dielectric function and invert
    !! - 'iter' or 'iterative' to determine the inverse of the dielectric function iteratively
    !! which requires no matrix inversion and hence less memory
    CHARACTER(LEN=256) :: solve_coul
    !
    !> Number of iterations for the iterative solver.
    INTEGER :: num_iter_coul
    !
    !> Number of potentials that are mixed in the iterative solver.
    INTEGER :: num_mix_coul
    !
    !> Use the small group of q to reduce the amount of G vectors for which the
    !! linear response is calculated.
    LOGICAL :: use_symm_coul
    !
    !> Shift of the projector used in the linear response equation. If negative
    !! will be determined automatically (only for semiconductors). For metals set to a
    !! small value (1e-5) and converge towards 0 until the dielectric response doesn't change.
    REAL(DP) :: shift_proj
    !
    !> Order in which the linear solvers are tried for the Coulomb interaction
    !!
    !! - 1 - BiCGstab(l) with multishift
    !! - 2 - BiCGstab(l) without multishift
    !! - 3 - linear solver developed for SternheimerGW
    !! - 0 - no linear solver
    INTEGER, DIMENSION(10) :: priority_coul
    !
    !> The threshold to which the linear solver is converged. For the iterative solver
    !! smaller values are necessary (~1e-8).
    REAL(DP) :: thres_coul
    !
    !> The maximum number of iterations a linear solver will try before aborting.
    INTEGER :: max_iter_coul
    !
    !> The parameter lmax controls the number of BiCG steps in the BiCGstab solver
    !! before doing an MR step. It has no effect for other solvers.
    INTEGER :: lmax_coul
    !
    !> Model used to perform the analytic continuation from the coarse mesh, on which
    !! the linear solver works, onto the dense mesh, where the integration is performed.
    !! Possible choices
    !!
    !! - 'gn', 'pp', or 'godby-needs', Godby-Needs plasmon pole model
    !! - 'pade', Pade approximation
    !! - 'pade robust', robust method to determine Pade approximant, requires the initial
    !! frequency mesh to be on a circle
    !!
    !! - 'aaa' adaptive Antoulas-Anderson (AAA) method for calcuting a rational approximant
    !! - 'aaa pole' AAA method combined with removal of weak residue
    CHARACTER(LEN=256) :: model_coul
    !
    !> Select which method is used to enforce the W(w) = W(-w) symmetry to improve
    !! the accuracy of the Pade approximation. Only works if model_coul is 'pade' or 'aaa'
    !! where by default the number of points are doubles. Note that switching off symmetry
    !! should only be used for testing purposes.
    !! Possible choices
    !!
    !! - 0 do not use symmetry
    !! - 1 for every frequency w /= 0 also add W(-w) with the same value
    !! - 2 fit W(w^2) instead of W(w)
    INTEGER :: freq_symm_coul
    !
    !> Upper boundary of the frequency integration grid when convoluting G and W
    !! (in eV). Note that we will integrate from -x to x, where x is the value set here.
    REAL(DP) :: max_freq_coul
    !
    !> Number of frequency points in the integration grid when convoluting G and W.
    INTEGER :: num_freq_coul
    !
    !> Plot the screened Coulomb interaction along the real or imaginary frequency
    !! axis with the grid set by max_freq_coul and num_freq_coul. Note that you should reduce
    !! the correlation cutoff or the q-point grid otherwise you will write a lot of data.
    LOGICAL :: plot_coul
    !
    !> Order in which the linear solvers are tried for the Green's function
    !!
    !! - 1 - BiCGstab with multishift
    !! - 2 - BiCGstab without multishift
    !! - 3 - linear solver developed for SternheimerGW
    !! - 0 - no linear solver
    INTEGER, DIMENSION(10) :: priority_green
    !
    !> The threshold to which the linear solver for the Green's function is converged.
    REAL(DP) :: thres_green
    !
    !> The maximum number of iterations a linear solver will try before aborting.
    INTEGER :: max_iter_green
    !
    !> The parameter lmax controls the number of BiCG steps in the BiCGstab solver
    !! before doing an MR step. It has no effect for other solvers.
    INTEGER :: lmax_green
    !
    !> Determines whether the correlation self energy is evaluated.
    LOGICAL :: do_corr
    !
    !> Energy cutoff used to evaluate the correlation self energy. Important
    !! convergence parameter with very significant impact on computation time.
    REAL(DP) :: ecut_corr
    !
    !> Lower frequency boundary (in eV) for the correlation self energy. Set to 0
    !! when using imaginary axis integration or the minimum relevant frequency for integration
    !! along the real axis.
    REAL(DP) :: min_freq_corr
    !
    !> Upper frequency boundary (in eV) for the correlation self energy. Convergence
    !! parameter when using imaginary axis integration or the maximum relevant frequency for
    !! integration along the real axis.
    REAL(DP) :: max_freq_corr
    !
    !> Number of frequency points for the correlation self energy. Convergence parameter
    !! when using imaginary axis integration.
    INTEGER :: num_freq_corr
    !
    !> Determines whether the exchange self energy is evaluated.
    LOGICAL :: do_exch
    !
    !> Energy cutoff used to evaluate the exchange self energy.
    REAL(DP) :: ecut_exch
    !
    !> Determines whether the matrix elements of the self energy are calculated.
    LOGICAL :: do_matrix_el
    !
    !> Lower frequency boundary for window in which the matrix elements of the
    !! self energy are evaluated (for imaginary frequency integration only).
    REAL(DP) :: min_freq_wind
    !
    !> Upper frequency boundary for window in which the matrix elements of the
    !! self energy are evaluated (for imaginary frequency integration only).
    REAL(DP) :: max_freq_wind
    !
    !> Number of frequency points in window in which the matrix elements of the
    !! self energy are evaluated (for imaginary frequency integration only).
    INTEGER :: num_freq_wind
    !
    !> This can be used to restart a calculation where not all of the q points
    !! finished. It determines for which q point the screened Coulomb interaction is evaluated.
    INTEGER :: first_qpt
    !
    !> This can be used for convergence testing or debugging purposes. It will
    !! abort the calculation after the screened Coulomb interaction for a single q point is
    !! evaluated.
    LOGICAL :: only_one_qpt
    !
    !> This can be used to limit the k points for which the correlation self
    !! energy is evaluated. This determines the lower limit, use last_kpt for the upper limit.
    INTEGER :: first_kpt
    !
    !> This can be used to limit the k points for which the correlation self
    !! energy is evaluated. This determines the upper limit, use last_kpt for the lower limit.
    !! If set to -2 (default), all k points are calculated.
    INTEGER :: last_kpt
    !
    !> Verbosity of the output in the NSCF calculation. Set to either 'low'
    !! (default) or 'high'.
    CHARACTER(LEN=80) :: verbosity
    !
    !> Allows to activate debugging for various parts of the code. Note that the
    !! code must be compiled with 'make debug' to enable debugging.
    TYPE(DEBUG_TYPE) :: debug

    !
    !  variables used for namelist gw_output
    !
    !> Directory in which the files generated by SternheimerGW are stored. If
    !! not set, it will default to the PW outdir.
    CHARACTER(LEN=256) :: directory
    !
    !> Extension to filename in which the screened Coulomb matrix is stored. The
    !! file generated will have the name prefix.file_coul.
    CHARACTER(LEN=256) :: file_coul
    !
    !> Extension to filename in which the exchange contribution is stored. The
    !! file generated will have the name prefix.file_exch.
    CHARACTER(LEN=256) :: file_exch
    !
    !> Extension to filename in which the correlation contribution is stored. The
    !! file generated will have the name prefix.file_corr.
    CHARACTER(LEN=256) :: file_corr
    !
    !> XML file that contains both exchange and correlation contribution and some
    !! information to allow reading that information.
    CHARACTER(LEN=256) :: file_sigma
    !
    !> If set, write the eigenvalues obtained in the DFT calculation along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_dft
    !
    !> If set, write the quasi-particle eigenvalues calculation along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_gw
    !
    !> If set, write the expectation value of the exchange-correlation potential along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_vxc
    !
    !> If set, write the expectation value of the bare HF exchange along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_hf
    !
    !> If set, write the quasi-particle renormalization factor Z along the
    !! specified k-point path in this file in a format compatible with bands.x.
    CHARACTER(LEN=256) :: file_renorm

    !> error flag returned by reading the namelist
    INTEGER :: ierr

    NAMELIST /GW_INPUT/ &
      title, prefix, outdir, kpt_grid, qpt_grid, truncation, num_band, int_imag_axis, &
      eta, do_coul, do_epsil, solve_coul, num_iter_coul, num_mix_coul, use_symm_coul, &
      shift_proj, priority_coul, thres_coul, max_iter_coul, lmax_coul, model_coul, &
      freq_symm_coul, max_freq_coul, num_freq_coul, plot_coul, priority_green, &
      thres_green, max_iter_green, lmax_green, do_corr, ecut_corr, min_freq_corr, &
      max_freq_corr, num_freq_corr, do_exch, ecut_exch, do_matrix_el, min_freq_wind, &
      max_freq_wind, num_freq_wind, first_qpt, only_one_qpt, first_kpt, last_kpt, &
      verbosity, debug

    NAMELIST /GW_OUTPUT/ &
      directory, file_coul, file_exch, file_corr, file_sigma, file_dft, file_gw, &
      file_vxc, file_hf, file_renorm

    CALL input_from_file()

    !
    ! set the default values
    !
    ! namelist gw_input
    title = 'SternheimerGW'
    prefix = 'pwscf'
    outdir = './'
    kpt_grid = [0, 0, 0]
    qpt_grid = [0, 0, 0]
    truncation = 'on'
    num_band = 0
    int_imag_axis = .TRUE.
    eta = 0.1_dp
    do_coul = .TRUE.
    do_epsil = .FALSE.
    solve_coul = 'direct'
    num_iter_coul = 1000
    num_mix_coul = 4
    use_symm_coul = .TRUE.
    shift_proj = -1.0_dp
    priority_coul = [1, 3, 0, 0, 0, 0, 0, 0, 0, 0]
    thres_coul = 1e-4_dp
    max_iter_coul = 1000
    lmax_coul = 4
    model_coul = 'pade'
    freq_symm_coul = 1
    max_freq_coul = 100.0_dp
    num_freq_coul = 50
    plot_coul = .FALSE.
    priority_green = [1, 3, 0, 0, 0, 0, 0, 0, 0, 0]
    thres_green = 1e-4_dp
    max_iter_green = 1000
    lmax_green = 4
    do_corr = .TRUE.
    ecut_corr = 15.0_dp
    min_freq_corr = 0.0_dp
    max_freq_corr = 100.0_dp
    num_freq_corr = 11
    do_exch = .TRUE.
    ecut_exch = 20.0_dp
    do_matrix_el = .TRUE.
    min_freq_wind = -50.0_dp
    max_freq_wind = 30.0_dp
    num_freq_wind = 801
    first_qpt = 1
    only_one_qpt = .FALSE.
    first_kpt = 1
    last_kpt = -2
    verbosity = 'low'
    ! namelist gw_output
    directory = ''
    file_coul = 'coul'
    file_exch = 'exch'
    file_corr = 'corr'
    file_sigma = 'sigma.xml'
    file_dft = ''
    file_gw = ''
    file_vxc = ''
    file_hf = ''
    file_renorm = ''

    !
    ! read the namelist from stdin
    !
    READ(stdin, NML=gw_input, IOSTAT=ierr)
    CALL errore(__FILE__, "error reading namelist gw_input ", ierr)

    READ(stdin, NML=gw_output, IOSTAT=ierr)
    CALL errore(__FILE__, "error reading namelist gw_output ", ierr)

    !
    ! copy the namelist variables to the output type
    !
    ! namelist gw_input
    gw_input_t%title = title
    gw_input_t%prefix = prefix
    gw_input_t%outdir = outdir
    gw_input_t%kpt_grid = kpt_grid
    gw_input_t%qpt_grid = qpt_grid
    gw_input_t%truncation = truncation
    gw_input_t%num_band = num_band
    gw_input_t%int_imag_axis = int_imag_axis
    gw_input_t%eta = eta
    gw_input_t%do_coul = do_coul
    gw_input_t%do_epsil = do_epsil
    gw_input_t%solve_coul = solve_coul
    gw_input_t%num_iter_coul = num_iter_coul
    gw_input_t%num_mix_coul = num_mix_coul
    gw_input_t%use_symm_coul = use_symm_coul
    gw_input_t%shift_proj = shift_proj
    gw_input_t%priority_coul = priority_coul
    gw_input_t%thres_coul = thres_coul
    gw_input_t%max_iter_coul = max_iter_coul
    gw_input_t%lmax_coul = lmax_coul
    gw_input_t%model_coul = model_coul
    gw_input_t%freq_symm_coul = freq_symm_coul
    gw_input_t%max_freq_coul = max_freq_coul
    gw_input_t%num_freq_coul = num_freq_coul
    gw_input_t%plot_coul = plot_coul
    gw_input_t%priority_green = priority_green
    gw_input_t%thres_green = thres_green
    gw_input_t%max_iter_green = max_iter_green
    gw_input_t%lmax_green = lmax_green
    gw_input_t%do_corr = do_corr
    gw_input_t%ecut_corr = ecut_corr
    gw_input_t%min_freq_corr = min_freq_corr
    gw_input_t%max_freq_corr = max_freq_corr
    gw_input_t%num_freq_corr = num_freq_corr
    gw_input_t%do_exch = do_exch
    gw_input_t%ecut_exch = ecut_exch
    gw_input_t%do_matrix_el = do_matrix_el
    gw_input_t%min_freq_wind = min_freq_wind
    gw_input_t%max_freq_wind = max_freq_wind
    gw_input_t%num_freq_wind = num_freq_wind
    gw_input_t%first_qpt = first_qpt
    gw_input_t%only_one_qpt = only_one_qpt
    gw_input_t%first_kpt = first_kpt
    gw_input_t%last_kpt = last_kpt
    gw_input_t%verbosity = verbosity
    gw_input_t%debug = debug

    ! namelist gw_output
    gw_output_t%directory = directory
    gw_output_t%file_coul = file_coul
    gw_output_t%file_exch = file_exch
    gw_output_t%file_corr = file_corr
    gw_output_t%file_sigma = file_sigma
    gw_output_t%file_dft = file_dft
    gw_output_t%file_gw = file_gw
    gw_output_t%file_vxc = file_vxc
    gw_output_t%file_hf = file_hf
    gw_output_t%file_renorm = file_renorm

  END SUBROUTINE gw_input_read

  !> broadcast input to all CPU
  SUBROUTINE gw_input_bcast(gw_input_t, gw_output_t)

    USE io_global, ONLY : meta_ionode_id
    USE mp,        ONLY : mp_bcast
    USE mp_world,  ONLY : world_comm
    USE debug_module, ONLY : mp_bcast_debug

    !> contains the user input in namelist gw_input
    TYPE(gw_input_type), INTENT(INOUT) :: gw_input_t

    !> contains the user input in namelist gw_output
    TYPE(gw_output_type), INTENT(INOUT) :: gw_output_t

    !
    ! broadcast all variables
    !
    ! namelist gw_input
    CALL mp_bcast(gw_input_t%title, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%prefix, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%outdir, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%kpt_grid, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%qpt_grid, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%truncation, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%num_band, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%int_imag_axis, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%eta, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%do_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%do_epsil, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%solve_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%num_iter_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%num_mix_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%use_symm_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%shift_proj, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%priority_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%thres_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%max_iter_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%lmax_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%model_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%freq_symm_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%max_freq_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%num_freq_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%plot_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%priority_green, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%thres_green, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%max_iter_green, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%lmax_green, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%do_corr, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%ecut_corr, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%min_freq_corr, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%max_freq_corr, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%num_freq_corr, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%do_exch, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%ecut_exch, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%do_matrix_el, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%min_freq_wind, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%max_freq_wind, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%num_freq_wind, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%first_qpt, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%only_one_qpt, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%first_kpt, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%last_kpt, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_input_t%verbosity, meta_ionode_id, world_comm)
    CALL mp_bcast_debug(gw_input_t%debug, meta_ionode_id, world_comm)

    ! namelist gw_output
    CALL mp_bcast(gw_output_t%directory, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_output_t%file_coul, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_output_t%file_exch, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_output_t%file_corr, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_output_t%file_sigma, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_output_t%file_dft, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_output_t%file_gw, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_output_t%file_vxc, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_output_t%file_hf, meta_ionode_id, world_comm)
    CALL mp_bcast(gw_output_t%file_renorm, meta_ionode_id, world_comm)

  END SUBROUTINE gw_input_bcast

END MODULE gw_input_module
